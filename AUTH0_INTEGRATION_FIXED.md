# Auth0 Integration - Fixed Implementation

## Overview
Your Spring Boot backend now handles **local user creation and authentication** while also supporting **Auth0 social login**. This hybrid approach gives you the best of both worlds.

## How It Works

### 1. Two Authentication Flows

#### Flow A: Traditional Email/Password (Your Local System)
```
User → /api/auth/register → Backend creates user → Returns local JWT
User → /api/auth/login → Backend validates credentials → Returns local JWT
```

#### Flow B: Auth0 Social Login (Google/Facebook)
```
User → Auth0 Login → Auth0 returns Auth0 JWT → 
Frontend → /api/auth/auth0/sync (with Auth0 JWT) →
Backend validates Auth0 JWT → Creates/updates user → Returns LOCAL JWT →
Frontend uses local JWT for all subsequent requests
```

### 2. Token Handling

**Two Types of JWT Tokens:**

1. **Auth0 JWT Token** (from Auth0)
   - Used ONLY for the `/api/auth/auth0/sync` endpoint
   - Validated by Spring Security's OAuth2 Resource Server
   - Short-lived, used for initial authentication
   
2. **Local JWT Token** (from your backend)
   - Generated by `JwtTokenProvider.generateToken(user)`
   - Used for ALL authenticated requests after sync
   - Stored in localStorage as `auth_token`

### 3. Backend Architecture

#### Security Configuration (`SecurityConfiguration.java`)
```java
// Two authentication mechanisms:
1. Custom JWT Filter (for local tokens) → Most endpoints
2. OAuth2 Resource Server (for Auth0 tokens) → /api/auth/auth0/sync
```

#### JWT Authentication Filter (`JwtAuthenticationFilter.java`)
```java
// CRITICAL: Skips Auth0 endpoints to avoid conflict
if (path.contains("/api/auth/auth0/")) {
    filterChain.doFilter(request, response);
    return;
}
```

#### Auth Service (`AuthService.java`)
```java
public AuthResponseDTO syncAuth0User(...) {
    // 1. Find or create user in local database
    User user = userRepository.findByOauthProviderAndOauthProviderId("auth0", sub)
        .orElseGet(() -> createNewUser());
    
    // 2. Generate LOCAL JWT token
    String localToken = jwtTokenProvider.generateToken(user);
    
    // 3. Return local token to frontend
    return AuthResponseDTO.builder()
        .token(localToken)  // ← This is the key!
        .user(userDTO)
        .build();
}
```

### 4. Frontend Flow

#### Auth0 Callback Component
```typescript
// 1. Auth0 completes authentication
auth0.isAuthenticated$.subscribe(isAuth => {
    
    // 2. Get Auth0 user and token
    auth0.user$.subscribe(auth0User => {
        auth0.getAccessTokenSilently().subscribe(auth0Token => {
            
            // 3. Send Auth0 token to backend for validation
            authService.syncAuth0User(auth0User, auth0Token).subscribe({
                
                // 4. Backend returns LOCAL JWT token
                // 5. AuthService stores LOCAL token in localStorage
                // 6. All future requests use LOCAL token
                next: () => router.navigate(['/'])
            });
        });
    });
});
```

#### Auth Service
```typescript
syncAuth0User(auth0User, auth0Token) {
    // Send Auth0 token in Authorization header
    return http.post('/api/auth/auth0/sync', userData, {
        headers: { 'Authorization': `Bearer ${auth0Token}` }
    }).pipe(
        map(response => {
            // Backend returns AuthResponse with LOCAL JWT token
            this.handleAuthSuccess(response.data);  // Stores LOCAL token
            return response.data.user;
        })
    );
}
```

## Why This Approach?

### ✅ Benefits
1. **Your backend controls user data** - All users stored in YOUR database
2. **Consistent authentication** - Same User entity for both auth methods
3. **Single token type for API calls** - Frontend only uses local JWT after sync
4. **Full control** - You can add custom claims, permissions, etc.
5. **Easy migration** - Can switch providers without changing your API

### ❌ What Was Wrong Before
1. Frontend tried to use Auth0 token for backend API calls
2. Backend JWT filter tried to parse Auth0 tokens (different structure)
3. No local user record created for Auth0 users
4. Token validation conflicts between custom JWT and OAuth2

## Configuration Checklist

### Backend (`application-dev.yml`)
```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://dev-k03ztn804p2l0zs8.us.auth0.com/
          audiences: https://stayease-api
```

### Frontend (`environment.development.ts`)
```typescript
auth0: {
  domain: 'dev-k03ztn804p2l0zs8.us.auth0.com',
  clientId: 'VbSEaE4pZLPwIoGAd5N8ue23H8ci2wQs',
  audience: 'https://stayease-api',
  redirectUri: 'http://localhost:4200/callback'
}
```

### Auth0 Dashboard Settings
1. **Application Settings**:
   - Allowed Callback URLs: `http://localhost:4200/callback`
   - Allowed Logout URLs: `http://localhost:4200`
   - Allowed Web Origins: `http://localhost:4200`

2. **API Settings**:
   - Create API with identifier: `https://stayease-api`
   - Enable RS256 signing

3. **Social Connections**:
   - Enable Google and/or Facebook
   - Connect them to your application

## Testing

### 1. Test Traditional Login
```bash
# Should work as before
POST /api/auth/register
POST /api/auth/login
```

### 2. Test Auth0 Login
```bash
# 1. Frontend redirects to Auth0
# 2. User logs in with Google/Facebook
# 3. Auth0 redirects to /callback
# 4. Frontend calls /api/auth/auth0/sync with Auth0 token
# 5. Backend validates Auth0 token via OAuth2 resource server
# 6. Backend creates/updates user in local DB
# 7. Backend returns LOCAL JWT token
# 8. Frontend stores LOCAL JWT token
# 9. All subsequent requests use LOCAL JWT token
```

## Troubleshooting

### Error: "Unauthorized" on callback
**Cause**: Auth0 application settings not configured correctly
**Fix**: Add callback URL in Auth0 dashboard

### Error: "Invalid token" 
**Cause**: Using Auth0 token for non-sync endpoints
**Fix**: Ensure frontend uses local token from sync response

### Error: "Audience validation failed"
**Cause**: API not created in Auth0 or wrong audience
**Fix**: Create API with identifier `https://stayease-api` exactly

### Error: "Issuer validation failed"
**Cause**: Wrong Auth0 domain in backend config
**Fix**: Update `issuer-uri` in application-dev.yml

## Database Schema

Auth0 users are stored in your `users` table:
```sql
oauth_provider = 'auth0'
oauth_provider_id = <Auth0 sub>  -- e.g., "auth0|123456"
email = <from Auth0>
first_name = <from Auth0 given_name>
last_name = <from Auth0 family_name>
profile_image_url = <from Auth0 picture>
is_email_verified = <from Auth0 email_verified>
```

## Summary
- ✅ Backend creates and manages all users locally
- ✅ Auth0 provides social login convenience
- ✅ Backend validates Auth0 tokens for sync
- ✅ Backend issues LOCAL JWT tokens for API access
- ✅ Single authentication system for all requests
- ✅ Full control over user data and permissions
